#!/usr/bin/perl
#
# Install UBOS on one or more currently unmounted devices or disk images,
# or in a directory.
#

use strict;
use warnings;

use Getopt::Long qw( :config pass_through );

use UBOS::Logging;
use UBOS::Utils;

my $verbose;
my $logConfigFile;
my $debug;
my $help;
my $listDeviceClasses;
my $deviceConfigFile;
my $arch;
my $deviceClass;
my $hostname;
my $channel;
my $productInfoFile;
my @additionalPackages;
my @additionalServices;
my @additionalKernelModules;
my @additionalKernelParameters;
my $installDepotRoot;
my $runDepotRoot;
my $installCheckSignatures;
my $runCheckSignatures;
my %addPackageDbs;
my @disablePackageDbs;
my @bootLoaderDevices;
my @bootPartitions;
my @rootPartitions;
my @ubosPartitions;
my @swapPartitions;
my $swap;


my $parseOk = GetOptions(
        'verbose+'                   => \$verbose,
        'logConfig=s'                => \$logConfigFile,
        'debug'                      => \$debug,
        'h|help'                     => \$help,

        'listdeviceclasses'          => \$listDeviceClasses,

        'device-config=s'            => \$deviceConfigFile,

        'arch=s'                     => \$arch,
        'deviceclass=s'              => \$deviceClass,

        'hostname=s'                 => \$hostname,
        'channel=s'                  => \$channel,
        'product-info=s'             => \$productInfoFile,

        'add-package=s'              => \@additionalPackages,
        'add-service=s'              => \@additionalServices,
        'add-kernel-module=s'        => \@additionalKernelModules,
        'add-kernel-parameter=s'     => \@additionalKernelParameters,

        'install-depot-root=s'       => \$installDepotRoot,
        'run-depot-root=s'           => \$runDepotRoot,
        'install-check-signatures=s' => \$installCheckSignatures,
        'run-check-signatures=s'     => \$runCheckSignatures,

        'add-package-db=s'           => \%addPackageDbs,
        'disable-package-db=s'       => \@disablePackageDbs,

        'bootloaderdevice=s'         => \@bootLoaderDevices,
        'bootpartition=s'            => \@bootPartitions,
        'rootpartition=s'            => \@rootPartitions,
        'ubospartition=s'            => \@ubosPartitions,
        'swappartition=s'            => \@swapPartitions,
        'swap!'                      => \$swap );

UBOS::Logging::initialize( 'ubos-install', undef, $verbose, $logConfigFile, $debug );

if( $help ) {
    synopsisHelpQuit( 1 );
}
if( !$parseOk ) {
    synopsisHelpQuit( 0 );
}

if(      $listDeviceClasses
    && (    $deviceConfigFile
         || $arch
         || $deviceClass
         || $hostname
         || $channel
         || $productInfoFile
         || @additionalPackages
         || @additionalServices
         || @additionalKernelModules
         || @additionalKernelParameters
         || $installDepotRoot
         || $runDepotRoot
         || $installCheckSignatures
         || $runCheckSignatures
         || keys %addPackageDbs
         || @disablePackageDbs
         || $swap ))
{
    synopsisHelpQuit( 0 );
}

if( $listDeviceClasses ) {
    listInstallersQuit();
}

# Just invoking help doesn't trigger this check
if ( $< != 0 ) {
    fatal( "This command must be run as root" );
}

my $deviceConfig;
if( $deviceConfigFile ) {
    $deviceConfig = UBOS::Utils::readJsonFromFile( $deviceConfigFile );
    unless( $deviceConfig ) {
        fatal();
    }
} else {
    $deviceConfig = {};
}

# Merge copmmand-line arguments into $deviceConfig, overriding whatever is
# given there. Do no checking at this time; we do this all at the same time later

if( $hostname ) {
    $deviceConfig->{hostname} = $hostname;
}
if( $channel ) {
    $deviceConfig->{channel} = $channel;
}
if( $productInfoFile ) {
    my $productInfo = UBOS::Utils::readJsonFromFile( $productInfoFile );
    unless( $productInfo ) {
        fatal( $! );
    }
    $deviceConfig->{productinfo} = $productInfo;
}
if( @additionalPackages ) {
    $deviceConfig->{additionalpackages} = \@additionalPackages;
}
if( @additionalServices ) {
    $deviceConfig->{additionalservices} = \@additionalServices;
}
if( @additionalKernelModules ) {
    $deviceConfig->{additionalkernelmodules} = \@additionalKernelModules;
}
if( @additionalKernelParameters ) {
    $deviceConfig->{additionalkernelparameters} = \@additionalKernelParameters;
}
if( $installDepotRoot ) {
    $deviceConfig->{installdepotroot} = $installDepotRoot;
}
if( $runDepotRoot ) {
    $deviceConfig->{rundepotroot} = $runDepotRoot;
}
if( $installCheckSignatures ) {
    $deviceConfig->{installchecksignatures} = $installCheckSignatures;
}
if( $runCheckSignatures ) {
    $deviceConfig->{runchecksignatures} = $runCheckSignatures;
}
if( keys %addPackageDbs ) {
    $deviceConfig->{addpackagedbs} = \%addPackageDbs;
}
if( @disablePackageDbs ) {
    $deviceConfig->{disablepackagedbs} = \@disablePackageDbs;
}
if( $swap ) {
    $deviceConfig->{swap} = $swap;
}
if( @ARGV ) {
    $deviceConfig->{installtargets} = \@ARGV;
}

# Defaults for $arch and $deviceClass are determined here so we can
# find the right Installer. All other defaults are determined by
# the Installer itself.

my $tmp;
unless( $arch ) {
    $arch = UBOS::Utils::arch();
}
$tmp = UBOS::Utils::isValidArch( $arch );
unless( $tmp ) {
    fatal( 'Invalid arch:', $arch );
}
$arch = $tmp;

unless( $deviceClass ) {
    $deviceClass = UBOS::Utils::deviceClass();
}
$tmp = UBOS::Utils::isValidDeviceClass( $deviceClass );
unless( $tmp ) {
    fatal( 'Invalid device class:', $deviceClass );
}
$deviceClass = $tmp;

# Find installer, configure it with the deviceConfig and complete/validate

my $installer = findInstaller( $arch, $deviceClass );
unless( $installer ) {
    fatal( 'Cannot find installer for arch', $arch, 'deviceclass', $deviceClass );
}

trace( 'Using installer', ref( $installer ));

my $errors = $installer->setDeviceConfig( $deviceConfig );
if( $errors ) {
    goto END;
}
$errors = $installer->checkComplete();
if( $errors ) {
    goto END;
}

# Do the installation

trace( 'Checking the network' );
unless( UBOS::Utils::isOnline() ) {
    fatal( 'Cannot reach the UBOS software depot; leaving system and disks unchanged' );
}

$errors = $installer->install();

# Done

END:
if( $errors ) {
    info( 'There were', $errors, 'errors.' );
    exit( 1 );
}
exit( 0 );


##
# Find the right installer for this device class
sub findInstaller {
    my $archName        = shift;
    my $deviceClassName = shift;

    my $className = $archName . '-' . $deviceClassName;
    my $installers = getInstallers();
    my $installer  = $installers->{$className};

    unless( $installer ) {
        return undef;
    }

    my $ret = UBOS::Utils::invokeMethod( $installer . '->new' );
    return $ret;
}

##
# Get the available installers
my $_installers;
sub getInstallers {
    unless( $_installers ) {
        $_installers = UBOS::Utils::findPerlShortModuleNamesInPackage( 'UBOS::Install::Installers' );
    }
    return $_installers;
}

##
# List the available installers and quit
sub listInstallersQuit {
    my $installers = getInstallers();

    my @rows;
    my @colLengths = ( 0, 0, 0 );
    foreach my $key ( keys %$installers ) {
        my $installer = $installers->{$key};
        my $newRow = [
                UBOS::Utils::invokeMethod( $installer . '::arch' ),
                UBOS::Utils::invokeMethod( $installer . '::deviceClass' ),
                UBOS::Utils::invokeMethod( $installer . '::help' )
        ];
        $colLengths[0] = _max( $colLengths[0], length( $newRow->[0] ));
        $colLengths[1] = _max( $colLengths[1], length( $newRow->[1] ));
        $colLengths[2] = _max( $colLengths[2], length( $newRow->[2] ));
        push @rows, $newRow;
    }
    @rows = sort { ($a->[0] cmp $b->[0]) || ($a->[1] cmp $b->[1]) } @rows;

    printf( "%-" . $colLengths[0] . "s  %-" . $colLengths[1] . "s  %s\n", 'arch', 'deviceclass', 'description' );
    printf( '=' x ( $colLengths[0] + $colLengths[1] + $colLengths[2] + 4 ) . "\n" );

    foreach my $row ( @rows ) {
        printf( "%-" . $colLengths[0] . "s  %-" . $colLengths[1] . "s  %s\n", @$row );
    }

    exit( 0 );
}

#####
# Max value
sub _max {
    my $a = shift;
    my $b = shift;

    if( $a > $b ) {
        return $a;
    } else {
        return $b;
    }
}

#####
# Print synopsis or help
# $long: if true, print long help
# $exit: exit code
sub synopsisHelpQuit {
    my $long = shift;
    my $exit = shift || 0;

    if( $long ) {
        print <<END;
Install UBOS.
END
    } else {
        print "Synopsis:\n";
    }
    print "    $0 <device> ...\n";
    if( $long ) {
        print <<END;
        Install UBOS on <device>. <device> must be a disk device, or a pre-allocated disk image,
        or an empty directory.
        If more than one <device> is given, mirror across at least two disks (RAID1).
        WARNING: THIS WILL FORMAT <device>. ALL YOUR DATA ON IT WILL BE LOST.
END
    }

    print "    $0 --rootpartition <part>\n";
    if( $long ) {
        print <<END;
        Install UBOS on root partition <part>. <part> must be a partition such as /dev/sda3.
        If more than one root partition is given, mirror across at least two partitions (RAID1).
        WARNING: THIS WILL OVERWRITE all partitions you specify. ALL YOUR DATA ON THEM WILL BE LOST.
        However, it will not change the partition table, nor will it touch other partitions.
END
    }
    print "    $0 --config <file>\n";
    if( $long ) {
        print <<END;
        Use the information provided in the JSON file <file> to install UBOS.
        Any optional arguments override the information in the JSON file, except
        for the --addXXX arguments, which will be added together, and the --removeXXX
        arguments, which also will be added together.
END
    }
    print "    $0 --listdeviceclasses\n";
    if( $long ) {
        print <<END;
        Show the device classes that can be specified.
END
    }
    print "    $0 --help\n";
    if( $long ) {
        print <<END;
        Display help text.

END
    }
    if( $long ) {

        print <<END;
Optional arguments:
    --verbose
          Increase amount of status output.
    --logConfFile <log4perlconf>
          Alternate logging configuration file (not common).
    --channel <channel>
          The UBOS release channel; defaults to the release channel of the system on which
          the command is run.
    --hostname <hostname>
          The hostname to set; defaults to a deviceclass-specific name.
    --repository <path>
          Use this local UBOS repository for installation instead of http://depot.ubos.net/
    --depotroot <url>
          Use this URL for the root of the update repository instead of
          http://depot.ubos.net/<channel> where <channel> is the release channel
    --target <path>
          The directory to which the new system will be mounted temporarily during assembly.
          Defaults to a temp directoy in the current working directory. Make sure there
          is enough disk space for the entire system
    --arch <arch>
          The computer architecture, e.g. x86_64 or aarch. The architecture of the host on
          which $0 is run and the specified march must be the same, or results will be
          unpredictable.
    --deviceclass <class>
          The device class, e.g. rpi (Raspberry Pi), pc (x86_64 PC). The deviceclass must
          exist for the arch.
    --checksignatures <never|optional|required>
          Should package signatures be checked. Same as in pacman.conf(5). Defaults to required.
    --bootpartition <part>
          Use this block device as boot partition. If not provided, there will be no
          separate boot partition. Note that some systems (e.g. Raspberry Pi) cannot
          boot from a btrfs filesystem, and thus require that you specify a separate
          boot partition that can be formatted as vfat.
    --bootloaderdevice <dev>
          Install the boot loader on this block device. This is only required for
          some systems (e.g. PC) where boot loaders are written to a special place
          on the hard disk.
    --ubospartition <part>
          Use a separate /ubos partition. If more than one /ubos partition is given, mirror
          across at least two partitions (RAID1).
    --swappartion <part>
          Create a swap partition, or several if more than one is given.
    --addpackage <package>
          Name of an additional package to install beyond the default of the device class
    --addservice <service>
          Name of an additional systemd service to enable beyond the default of the device class
    --addmodule <module>
          Name of an additional kernel module to load beyond the default of the device class
    --addkernelparameter <parameter>
          Verbatim string to be appended to the kernel boot parameter. This currently only
          works on some device classes.
    --addpackagedb <name=server>
          Add an additional pacman repository, where <name> is the section name for the
          pacman configuration, and <server> is the URL where the packages can be found.
    --removepackagedb <name>
          Do not add one of the default UBOS repositories, where <name> is the section name
          for the default UBOS repository.
    --disablepackagedb <name>
          Disable one of the default UBOS repositories, where <name> is the section name
          for the default UBOS repository.
    --noswap
          Do not create a swap partition.
    --productfile <file>
          Use <file> as the JSON file from where to read production information.
END
    } else {
        print <<END;
Optional arguments:
    [--verbose][--logConfFile <log4perlconf>]
    [--channel <channel>][--hostname <hostname>][--repository <path>][--depotroot <url>][--target <path>]
    [--arch <arch>][--deviceclass <class>][--checksignatures <never|optional|required>]
    [--bootpartition <part>][--bootloaderdevice <dev>][--ubospartition <part>][--swappartition <part>]
    [--addpackage <package>][--addservice <service>][--addmodule <module>][--addkernelparameter <parameter>]
    [--addpackagedb <name=server>][--removepackagedb <name>][--disablepackagedb <name>][--noswap]
    [--productfile <file>]
END
    }
    exit 1;
}

1;
