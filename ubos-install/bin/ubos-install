#!/usr/bin/perl
#
# Install UBOS on one or more currently unmounted devices or disk images,
# or in a directory.
#
# Examples:
#     ubos-install /dev/sda
#             Install on a hard drive
#     ubos-install --hostname myserver /dev/sda /dev/sdb
#             Install on two hard drives in raid mode. Use provided hostname
#     ubos-install /some/file
#             Install on an image file. File must exist.
#     ubos-install --directory /some/directory
#             Install in a directory, to be run in a Linux container. Directory must exist.
#
# Copyright (C) 2014 and later, Indie Computing Corp. All rights reserved. License: see package.
#

use strict;
use warnings;

use Getopt::Long qw( :config pass_through );

use UBOS::Logging;
use UBOS::Utils;

my $verbose             = 0;
my $logConfigFile       = undef;
my $debug               = undef;
my $list                = 0;
my $ret                 = 0;
my $channel             = undef;
my $hostname            = undef;
my $archname            = undef;
my $deviceclassname     = undef;
my $target              = undef;
my $repo                = undef;
my $depotRoot           = undef;
my %additionalPackages  = ();
my %additionalServices  = ();
my %additionalModules   = ();
my @addKernelParameters = ();
my %addPackageDbs       = ();
my %removePackageDbs    = ();
my %disablePackageDbs   = ();
my $checkSignatures     = 'required';
my $noswap              = 0;
my $shepherdKeyFile     = 0;
my $help                = 0;

my $parseOk = GetOptions(
        'verbose+'             => \$verbose,
        'logConfig=s'          => \$logConfigFile,
        'debug'                => \$debug,
        'listdeviceclasses'    => \$list,
        'channel=s'            => \$channel,
        'hostname=s'           => \$hostname,
        'arch=s'               => \$archname,
        'deviceclass=s'        => \$deviceclassname,
        'target=s'             => \$target,
        'repository=s'         => \$repo,
        'depotroot=s'          => \$depotRoot,
        'addpackage=s'         => sub { _addCheck( \@_, \%additionalPackages ); },
        'addservice=s'         => sub { _addCheck( \@_, \%additionalServices ); },
        'addmodule=s'          => sub { _addCheck( \@_, \%additionalModules  ); },
        'addkernelparameter=s' => \@addKernelParameters,
        'addpackagedb=s'       => sub { _addCheck( \@_, \%addPackageDbs,     \%removePackageDbs, \%disablePackageDbs ); },
        'removepackagedb=s'    => sub { _addCheck( \@_, \%removePackageDbs,  \%addPackageDbs,    \%disablePackageDbs ); },
        'disablepackagedb=s'   => sub { _addCheck( \@_, \%disablePackageDbs, \%addPackageDbs,    \%removePackageDbs ); },
        'checksignatures=s'    => \$checkSignatures,
        'noswap'               => \$noswap,
        'shepherdkeyfile'      => \$shepherdKeyFile,
        'h|help'               => \$help );

UBOS::Logging::initialize( 'ubos-install', undef, $verbose, $logConfigFile, $debug );

if( !$parseOk ) {
    synopsisHelpQuit( 0 );
}
if( $help ) {
    synopsisHelpQuit( 1 );
}
if( $list ) {
    listInstallersQuit();
}

$checkSignatures = lc( $checkSignatures );
if( $checkSignatures ne 'never' && $checkSignatures ne 'optional' && $checkSignatures ne 'required' ) {
    synopsisHelpQuit( 0 );
}

# Just invoking help doesn't trigger this check
if ( $< != 0 ) {
    fatal( "This command must be run as root" );
}

if( $target && ! -d $target ) {
    fatal( 'Target is not a directory:', $target );
}
my $arch = UBOS::Utils::arch();
if( $archname ) {
    if( $arch ne $archname ) {
        warning( 'Specified arch', $archname, 'is different from the system arch', $arch,
                 '. This is unsupported and likely to fail.' );
    }
} else {
    # Use current arch if not given as parameter
    $archname = $arch;
}

# Use current device class if not given as parameter
unless( $deviceclassname ) {
    $deviceclassname = UBOS::Utils::deviceClass();
}
unless( $deviceclassname ) {
    fatal( 'Cannot automatically determine --deviceclass. Need to specify as argument.' );
}

my $installer = findInstaller( $archname, $deviceclassname );
unless( $installer ) {
    fatal( 'Cannot find installer for arch', $archname, 'deviceclass', $deviceclassname );
}

if( $target ) {
    $installer->setTarget( $target );
}
if( $hostname ) {
    $installer->setHostname( $hostname );
}
if( !$channel && -r '/etc/ubos/channel' ) {
    $channel = UBOS::Utils::slurpFile( '/etc/ubos/channel' );
    $channel =~ s!^\s+!!;
    $channel =~ s!\s+$!!;
}
if( $channel ) {
    $installer->setChannel( $channel );
}
if( $repo ) {
    $installer->setRepo( $repo );
}
if( $depotRoot ) {
    if( $depotRoot =~ m!/$! ) {
        fatal( 'Do not give a trailing slash for depotroot:', $depotRoot );
    }
    $installer->setDepotRoot( $depotRoot );
}
if( %additionalPackages ) {
    $installer->addPackages( keys %additionalPackages );
}
if( %additionalServices ) {
    $installer->addServices( keys %additionalServices );
}
if( %additionalModules ) {
    $installer->addPackages( keys %additionalModules );
}
if( @addKernelParameters ) {
    $installer->addKernelParameters( @addKernelParameters );
}
if( %addPackageDbs ) {
    $installer->addPackageDbs( keys %addPackageDbs );
}
if( %removePackageDbs ) {
    $installer->removePackageDbs( \%removePackageDbs );
}
if( %disablePackageDbs ) {
    $installer->disablePackageDbs( \%disablePackageDbs );
}
if( $shepherdKeyFile ) {
    my $shepherdKey = UBOS::Utils::slurpFile( $shepherdKeyFile );
    unless( $shepherdKey ) {
        fatal( $@ );
    }
    unless( $shepherdKey =~ m!^ssh-\S+ \S+ \S+\@\S+$! ) {
        fatal( 'This does not look like a valid ssh public key:', $shepherdKey );
    }
    $installer->setShepherdKey( $shepherdKey );
}
$installer->setCheckSignatures( $checkSignatures );

trace( 'Using installer', ref( $installer ));

my $diskLayout = $installer->createDiskLayout( $noswap, \@ARGV );
unless( $diskLayout ) {
    synopsisHelpQuit( 0 );
}
my $errors = $installer->install( $diskLayout );
if( $errors ) {
    info( 'There were', $errors, 'errors.' );
    $ret = 1;
}

exit( $ret );


##
# Find the right installer for this device class
sub findInstaller {
    my $archName        = shift;
    my $deviceClassName = shift;

    my $className = $archName . '-' . $deviceClassName;
    my $installers = getInstallers();
    my $installer  = $installers->{$className};

    unless( $installer ) {
        return undef;
    }

    my $ret = UBOS::Utils::invokeMethod( $installer . '->new' );
    return $ret;
}

##
# Get the available installers
my $_installers;
sub getInstallers {
    unless( $_installers ) {
        $_installers = UBOS::Utils::findPerlShortModuleNamesInPackage( 'UBOS::Install::Installers' );
    }
    return $_installers;
}

##
# List the available installers and quit
sub listInstallersQuit {
    my $installers = getInstallers();

    my @rows;
    my @colLengths = ( 0, 0, 0 );
    foreach my $key ( keys %$installers ) {
        my $installer = $installers->{$key};
        my $newRow = [
                UBOS::Utils::invokeMethod( $installer . '::arch' ),
                UBOS::Utils::invokeMethod( $installer . '::deviceClass' ),
                UBOS::Utils::invokeMethod( $installer . '::help' )
        ];
        $colLengths[0] = _max( $colLengths[0], length( $newRow->[0] ));
        $colLengths[1] = _max( $colLengths[1], length( $newRow->[1] ));
        $colLengths[2] = _max( $colLengths[2], length( $newRow->[2] ));
        push @rows, $newRow;
    }
    @rows = sort { ($a->[0] cmp $b->[0]) || ($a->[1] cmp $b->[1]) } @rows;

    printf( "%-" . $colLengths[0] . "s  %-" . $colLengths[1] . "s  %s\n", 'arch', 'deviceclass', 'description' );
    printf( '=' x ( $colLengths[0] + $colLengths[1] + $colLengths[2] + 4 ) . "\n" );

    foreach my $row ( @rows ) {
        printf( "%-" . $colLengths[0] . "s  %-" . $colLengths[1] . "s  %s\n", @$row );
    }

    exit( 0 );
}

#####
# Max value
sub _max {
    my $a = shift;
    my $b = shift;

    if( $a > $b ) {
        return $a;
    } else {
        return $b;
    }
}

##
# Add a command-line argument to a hash set. If exists already, emit error.
# Optionally, emit error if the same argument is already is one of several
# other hash sets.
# $nameValue: array[2] consisting of $name and $value.
# $addHere: hash set of the values for this parameter
# @notHere: array of hash set that cannot contain the value
sub _addCheck {
    my $nameValue = shift;
    my $addHere   = shift;
    my @notHere   = @_;

    my( $name, $value ) = @$nameValue;

    if( exists( $addHere->{$value} )) {
        fatal( 'Value of parameter', $name, 'set more than once:', $value );
    }
    foreach my $not ( @notHere ) {
        if( exists( $not->{$value} )) {
            fatal( 'Value of parameter', $name, 'cannot be both added and removed:', $value );
        }
    }
    $addHere->{$value} = 1;

    1;
}

#####
# Print synopsis or help
# $long: if true, print long help
# $exit: exit code
sub synopsisHelpQuit {
    my $long = shift;
    my $exit = shift || 0;

    if( $long ) {
        print <<END;
Install UBOS.
END
    } else {
        print "Synopsis:\n";
    }
    print "    $0 <device> ...\n";
    if( $long ) {
        print <<END;
        Install UBOS on <device>. <device> must be a disk device, or a pre-allocated disk image,
        or an empty directory.
        If more than one <device> is given, mirror across at least two disks (RAID1).
        WARNING: THIS WILL FORMAT <device>. ALL YOUR DATA ON IT WILL BE LOST.
END
    }

    print "    $0 [ --bootpartition <part> ][ --varpartition <part> ][ --bootloaderdevice <dev>] --rootpartition <part>\n";
    if( $long ) {
        print <<END;
        Install UBOS on root partition <part>. <part> must be a partition such as /dev/sda3.
        If more than one root partition is given, mirror across at least two partitions (RAID1).
        WARNING: THIS WILL OVERWRITE all partitions you specify. ALL YOUR DATA ON THEM WILL BE LOST.
        However, it will not change the partition table, nor will it touch other partitions.
END
    }
    print "    $0 --listdeviceclasses\n";
    if( $long ) {
        print <<END;
        Show the device classes that can be specified.
END
    }
    print "    $0 --help\n";
    if( $long ) {
        print <<END;
        Display help text.

END
    }
    if( $long ) {

        print <<END;
Optional arguments:
    --verbose
          Increase amount of status output.
    --logConfFile <log4perlconf>
          Alternate logging configuration file (not common).
    --channel <channel>
          The UBOS release channel; defaults to the release channel of the system on which
          the command is run.
    --hostname <hostname>
          The hostname to set; defaults to a deviceclass-specific name.
    --repository <path>
          Use this local UBOS repository for installation instead of http://depot.ubos.net/
    --depotroot <url>
          Use this URL for the root of the update repository instead of
          http://depot.ubos.net/<channel> where <channel> is the release channel
    --target <path>
          The directory to which the new system will be mounted temporarily during assembly.
          Defaults to a temp directoy in the current working directory. Make sure there
          is enough disk space for the entire system
    --arch <arch>
          The computer architecture, e.g. x86_64 or aarch. The architecture of the host on
          which $0 is run and the specified march must be the same, or results will be
          unpredictable.
    --deviceclass <class>
          The device class, e.g. rpi (Raspberry Pi), pc (x86_64 PC). The deviceclass must
          exist for the arch.
    --checksignatures <never|optional|required>
          Should package signatures be checked. Same as in pacman.conf(5). Defaults to required.
    --bootpartition <part>
          Use this block device as boot partition. If not provided, there will be no
          separate boot partition. Note that some systems (e.g. Raspberry Pi) cannot
          boot from a btrfs filesystem, and thus require that you specify a separate
          boot partition that can be formatted as vfat.
    --bootloaderdevice <dev>
          Install the boot loader on this block device. This is only required for
          some systems (e.g. PC) where boot loaders are written to a special place
          on the hard disk.
    --varpartition <part>
          Use a separate /var partition. If more than one var partition is given, mirror
          across at least two partitions (RAID1).
    --swappartion <part>
          Create a swap partition, or several if more than one is given.
    --addpackage <package>
          Name of an additional package to install beyond the default of the device class
    --addservice <service>
          Name of an additional systemd service to enable beyond the default of the device class
    --addmodule <module>
          Name of an additional kernel module to load beyond the default of the device class
    --addkernelparameter <parameter>
          Verbatim string to be appended to the kernel boot parameter. This currently only
          works on some device classes.
    --addpackagedb <name=server>
          Add an additional pacman repository, where <name> is the section name for the
          pacman configuration, and <server> is the URL where the packages can be found.
    --removepackagedb <name>
          Do not add one of the default UBOS repositories, where <name> is the section name
          for the default UBOS repository.
    --disablepackagedb <name>
          Disable one of the default UBOS repositories, where <name> is the section name
          for the default UBOS repository.
    --noswap
          Do not create a swap partition.
    --shepherdkeyfile <file>
          Create a shepherd account, and add the SSH public key from the provided file
          as a user that is allowed to log in via SSH.
END
    } else {
        print <<END;
Optional arguments:
    [--verbose][--logConfFile <log4perlconf>]
    [--channel <channel>][--hostname <hostname>][--repository <path>][--depotroot <url>][--target <path>]
    [--arch <arch>][--deviceclass <class>][--checksignatures <never|optional|required>]
    [--bootpartition <part>][--bootloaderdevice <dev>][--varpartition <part>][--swappartition <part>]
    [--addpackage <package>][--addservice <service>][--addmodule <module>][--addkernelparameter <parameter>]
    [--addpackagedb <name=server>][--removepackagedb <name>][--disablepackagedb <name>][--noswap]
    [--shepherdkeyfile <file>]
END
    }
    exit 1;
}

1;
